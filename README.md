Здесь должна быть рукописная мною инструкция, как пользоваться Git в разрезе GitHUB. Но поскольку в данном задании первостепенно не сотворение инструкции,  а демонстрация навыка pull request, то я позволил себе небольшую вольность и не буду сильно заморачиваться с инструкцией. К тому же уже сроки поджимают и надо торопиться.

Перед началом работы

git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты

git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера

Создать новый репозиторий

git init             # создать новый проект в текущей 
директории

Клонировать репозиторий в текущую директорию

git clone https://github.com:nicothin/web-design.git

Просмотр изменений

git status              # показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)

git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff index.html     # сравнить файл из рабочей директории и индекс

git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff --staged       # сравнить индекс и коммит с HEAD
git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master

git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов

git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master

Добавление изменений в индекс

git add .        # добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий

git add text.txt # добавить в индекс указанный файл (был изменён, был удалён или это новый файл)

git add -i       # запустить интерактивную оболочку для добавления в индекс только выбранных файлов

git add -p       # показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании

Коммиты

git commit -m "Name of commit"    # зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение

git commit -a -m "Name of commit" # проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение

Временно переключиться на другой коммит

git checkout b9533bb # переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)

git checkout master  # переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита)

Переключиться на другой коммит и продолжить работу с него

git checkout -b new-branch 5589877   # создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)

История коммитов

Выход из длинного лога вывода: q.

git log master             # показать коммиты в указанной ветке

git log -2                 # показать последние 2 коммита в активной ветке

git log -2 --stat          # показать последние 2 коммита и статистику внесенных ими изменений

git log -p -22             # показать последние 22 коммита и внесенную ими разницу на уровне строк

git log --graph -10        # показать последние 10 коммитов с ASCII-представлением ветвления

Ветки

git branch                 # показать список веток

git branch -v              # показать список веток и 
последний коммит в каждой

git branch new_branch      # создать новую ветку с указанным именем на текущем коммите

git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите

git branch -f master 5589877  # переместить ветку master на указанный коммит

git branch -f master master~2 # переместить ветку master на 2 коммита назад

git checkout new_branch    # перейти в указанную ветку
git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё

git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё

git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix

git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)

git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов

git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния

git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged        # показать ветки, уже слитые с активной

git branch --no-merged     # показать ветки, не слитые с активной

git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)

Удалённые репозитории

git remote -v              # показать список удалённых репозиториев, связанных с локальным

git branch -r              # показать удаленные ветки

git branch -a              # показать все ветки(локальные и удаленные)       

git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin

git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL

git remote rm origin       # удалить привязку удалённого репозитория

git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin

git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками

git fetch origin master    # то же, но скачивается только указанная ветка

git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё

git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master

git pull origin            # влить изменения с удалённого репозитория (все ветки)

git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)

Конфликт слияния

Предполагается ситуация: есть ветка master и есть ветка feature. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку master пытаемся влить ветку feature (git merge feature), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле index.html.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

git merge feature                # влить в активную ветку изменения из ветки feature

git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток

git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)

git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)

git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)

git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки

git reset --hard  # прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD, а я пойду немного поплачу

git reset --merge # прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)

git reset --abort # то же, что и строкой выше

